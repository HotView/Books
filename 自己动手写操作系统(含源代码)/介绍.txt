内容简介

　　本书从只有二十行的引导扇区代码出发，一步一步地向读者呈现一个操作系统框架的完成过程。书中不仅关注代码本身，同时关注完成这些代码的思路和过程。本书不同于其他的理论型书籍，而是提供给读者一个动手实践的路线图。读者可以根据路线图逐步完成各部分的功能，从而避免了一开始就面对整个操作系统数万行代码时的迷茫和挫败感。书中讲解了大量在开发操作系统中需注意的细节问题，这些细节不仅能使读者更深刻地认识操作系统的核心原理，而且使整个开发过程少走弯路。本书分上下两篇，共11章。其中每一章都以前一章的工作成果为基础，实现一项新的功能。而在章的内部，一项大的功能被分解成许多小的步骤，通过完成每个小的步骤，读者可以不断获得阶段性的成果，从而让整个开发过程变得轻松并且有趣。 　　本书适合各类程序员、程序开发爱好者阅读，也可作为高等院校操作系统课程的实践参考书。

序

　　做真正 Hacker的乐趣──自己动手去实践 　　2004年我听编辑说有个年轻人写了本《自己动手写操作系统》，第一反应是不可能，恐怕是翻译稿，写这种书籍是要考作者硬功夫的，不但需要深入掌握操作系统的原理，还需要实际动手写出原型。 　　历史上的 Linux就是这么产生的，Linus Torvalds当时是一名赫尔辛基大学计算机科学系的二年级学生，经常要用自己的电脑去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这成为了 Linux第一个内核的雏形。 　　我想中国有能力写出内核原型的程序员应该也有，但把这个题目写成一本书，感觉上不会有人愿意做这件事情，作者要花很多时间，加上主题比较硬，销售量不会太高，经济上回报有限。 　　但拿来文稿一看，整个编辑部大为惊艳，内容文笔俱佳，而且绝对原创，马上决定在《程序员》连载。2005年博文视点出版的第一版也广受好评。 　　不过有很多读者还是质疑：现在软件编程主要领域是框架和应用，还需要了解操作系统底层吗？ 　　经过四年的磨练成长，于渊又拿出第二版的书稿《Orange'S：一个操作系统的实现》，这本书是属于真正 Hacker的。我虽然已经有多年不写代码了，但看这本书的时候，让我又重新感受到做程序员的乐趣：用代码建设属于自己的系统，让电脑听从自己的指令，对系统的每个部分都了如指掌。 　　黑客（hacker）实际是褒义词，维基百科的解释是喜欢用智力通过创造性方法来挑战脑力极限的人，特别是他们所感兴趣的领域，例如软件编程或电气工程。个人电脑、软件和互联网等划时代的产品都是黑客创造出来的，如苹果的 Apple电脑、微软的 Basic解释器、互联网的 Mosaic浏览器。 　　回答前面读者的质疑，学软件编程并不需要看这本书，想成为优秀程序员和黑客的朋友，我强烈建议你花时间来阅读这本书，并亲自动手实践。正如于渊在本书结尾中所说“我们写自己的操作系统是出于一种好奇，或者说一种求知欲。我希望这样不停地‘过把瘾’能让这种好奇不停地延续”。 　　好奇心是动力的源泉，追究问题的本质是优秀黑客的必备素质，只有充分掌握了系统原理，才能在技术上游刃有余，才能有真正的创新和发展。中国需要更多真正的黑客，也希望更多的程序员能享受属于黑客的创造乐趣。 　　蒋涛 　　2009年 4月

作者自序

　　本书是《自己动手写操作系统》的第二版，通过一个具体的实例向读者呈现一个操作系统雏形的实现过程。有关操作系统的书籍资料可以找到很多，但是关注如何帮助读者实现一个试验性操作系统的书籍却不多见，本书便是从一个简单的引导扇区开始，讲述一个操作系统成长的故事，以作读者参考之用。 　　本书面向实践，通过具体实例教读者开发自己的操作系统。书中的步骤遵循由小到大、由浅入深的顺序，跟随这些步骤，读者可以由一个最简单的引导扇区开始，逐渐完善代码，扩充功能，最后形成一个小的操作系统。 　　本书不仅介绍操作系统的各要素，同时涉及开发操作系统需要的各个方面，比如如何建立开发环境、如何调试以及如何在虚拟机中运行等。书中的实例操作系统采用IA32作为默认平台，所以保护模式也作为必备知识储备收入书中，而这是传统的操作系统实践书籍经常忽略的。总之，只要是开发自己的操作系统中需要的知识，书中都尽量涉及，以便于读者参考。 　　众所周知，一个成型的操作系统往往非常复杂。如果考虑到操作系统作为软硬件桥梁的特殊地位，那么它可能看上去比一般的软件系统更难理解，因为其核心部分往往包含许多直接针对CPU、内存和 I/O端口的操作，它们夹杂在一片代码汪洋之中，显得更加晦涩。 　　我们有许多源代码公开的操作系统，可供随时下载和阅读，看上去好像让实现一个供自己把玩的微型操作系统变得容易很多，但事实往往不尽人意，因为这些代码动辄上万甚至几十几百万行，而且细节之间经常互相关联，要理解它们着实不易。我们有许多容易得到的操作系统教程，但读来好像总觉得跟我们有隔膜，不亲近。造成这些的根本原因，在于学习者一开始就面对一个完整的操作系统，或者面对前辈们积累了几十年的一系列理论成果。而无论作者多么擅长写作，读者多么聪明，或者代码多么优秀，要一个初学者理清其中的头绪都将是非常困难的。 　　我并非在此危言耸听，因为这曾经是我的亲身体会。当然，如果只是为了考试，几本操作系统理论书籍就足够了，你不需要对细节那么清楚。但如果是出于兴趣呢？如果你是想编写自己的操作系统呢？你会发现理论书籍好像一下子变得无用武之地，你会发现任何一个细节上的理解错误都可能导致自己辛辛苦苦编写的代码运行异常甚至崩溃。 　　我经历过这一切！我曾经翻遍了一本《操作系统：设计与实现》，也没有找到实现一个操作系统应该从何处着手。并不是这些书不好，也不是前人的代码不优秀，而是作为一无所知的初学者，我们所不了解的不仅是高居庙堂的理论知识，还有让我们举步维艰的实践细节。 　　可能在这些教科书作者的眼里，操作的细节不属于课程的一部分，或者这些细节看上去太容易，根本不值一提，甚至作者认为这些属于所谓“经验”的一部分，约定俗成是由读者本人去摸索的。但是实际情况往往是，这些书中忽略掉的内容恰恰占去了一个初学者大部分的时间，甚至影响了学习的热情。 　　我至今仍记得当我开始编写自己的操作系统时所遭受的挫败感，那是一种不知道如何着手的无助的感觉。还好我坚持了下来，克服了各种困难，并完成了自己的操作系统雏形。 　　进而我想到，一定不只是我一个人对编写自己的操作系统怀有兴趣，也一定不只是我一个人在实践时遇到困难。或许我应该把自己的经历写下来，从而可以帮助跟我相似的后来者，就这样，我编写了本书的第一版，也就是《自己动手写操作系统》。我相信，如果你也对神奇的计算机世界充满好奇，并且希望通过自己编写操作系统的方式来了解背后发生的故事，那么你一定可以在这本书中得到一些帮助。而假如你真的因为我的书而重新燃起实践的热情，从而开始一段操作系统旅程，我将会感到非常高兴。 　　不过我得坦白，在写作《自己动手写操作系统》的时候，我并不敢期待它能引起多少反响，一方面因为操作系统并不是时尚的话题，另一方面我也是走在学习的路上，或许只是比读者早走了一小步而已。然而出乎我的意料，它面世后重印多次，甚至一度登上销量排行榜的榜首，这让我觉得它的确有一定的参考价值，我要借此机会感谢所有支持我的读者。 　　在我写作《自己动手写操作系统》的时候，并没有想过今天会有一个第二版。原因在于，我希望这本书是用来填补空白的，而不是重复去做别人已经做得很好的事情。所谓填补空白，具体说就是让像我一样的操作系统爱好者在读完本书之后，能够有信心去读其他比较流行的开源的操作系统代码，有能力从零开始自己动手写操作系统，而这个任务第一版已经完成了。 　　那么为什么我又写作了第二版呢？原因有几个方面。第一，虽然第一版未曾涉及的进程间通信、文件系统等内容在许多书中都有讲解，但阅读的时候还是感觉有语焉不详的通病，作者本人可能很清楚原委，但写得太简略，以至于读者看来未必清晰。第二，我自己想把这个圈画圆。第一版的书虽然完成了它的使命，但毕竟到书的结尾，读者看到的不是一个真正的操作系统，它没有文件系统，没有内存管理，什么也干不了。在第二版中，你将会看到，你已经可以通过交叉编译的方式为我们的实验性 OS编写应用程序了，也就是说，它已经具备操作系统的基本功能，虽然仍然极其简陋，但第一个圈，毕竟是已经圆起来了。第三，实践类的操作系统书籍还是太少了，以至于你要想看看别人是怎么做的，除了读以《操作系统：设计与实现》为代表的极少数书籍之外，就是一头扎进源代码中，而结果有时相当令人气馁。我自己也气馁过，所以我在第二版中，仍然试图把话说细一点，把自己的经验拿出来分享。而且我选择我能想到的最精简的设计，以便让读者不至于陷入太多细节而无法看到全貌。我想这是本书可能具有的价值所在──简化的易懂的设计，还有尽量详细的文字。 　　在这一版中，内容被划分成上下两篇。上篇基本上是第一版的修订，只是做了一个调整，那便是在兼顾 Windows和Linux两方面用户的基础上，默认在Linux下建立开发环境来编写我们的操作系统。至于这样做的原因，在本书第 2章有比较详细的说明。当然，开发环境毕竟是第二位的，书中讲述的内容以及涉及的代码跟第一版都是一致的。本书的下篇全部都是新鲜内容，主要是增加了进程间通信、文件系统和内存管理。跟第一版的做法相同，下篇仍然不仅关注结果，更加致力于将形成一个结果的过程呈现出来。与此同时，由于本书旨在分享和引路，所以尽可能地简化了设计，以便将最重要的部分凸显出来。读者将看到，一个操作系统的文件系统和内存管理可以简陋到什么程度。简陋不是缺点，对于我们初学者而言，正是需要从简陋入手。换言之，如果你已经对实现一个操作系统有了一定的经验，那么这本书可能不适合你。这本书适合从来没有编写过操作系统的初学者。 　　本书的排版是我用L ATEX自己完成的。在排版中我花了一些工夫，因为我希望读者购买的首先是一本易于阅读且赏心悦目的书，其次才是编写操作系统的方法。另外，书中列出的代码均由我自己编写的程序自动嵌入L ATEX源文件，从而严格保证书和光盘的一致性，读者可以根据文件名和行号方便地找到光盘中 　　代码的准确位置。 　　此外，在第二版中还有一些小的变化。首先是操作系统的名字改变了，原因在于虽然我们的试验性 　　OS从前辈们那里借鉴了很多东西，但其各个部分的设计（比如文件系统和内存管理）往往有其独特之处，所以我将原先的 Tinix（本意为 TryMinix）改成了新名字Orange ’S（这个名字来自于我的妻子 ,），以表示它们的不同。另外，书中的代码风格，有些地方也做了调整。 　　我想，虽然第二版有着这样那样的变化，但有一点没有变，那就是本书试图将我在编写自己操作系统的过程中的经验尽可能地告诉读者，同时尽可能将我当初的思路和编码过程呈现出来。很可能读者比我更聪明，有更好的解决问题的方法，但无论如何，我认为我自己的经验可以为读者所借鉴。如果真是如 　　此，我将会非常欣慰。 　　在第二版的编写过程中，我同样要感谢许多人。感谢我的父母和爷爷对我的爱，并希望爷爷不要为我担心，写书是件辛苦的事，但同时也使我收获良多。爸爸在第二版的最后阶段帮我订正文字，这本书里有你的功劳。我要感谢博文视点的各位朋友，感谢郭老师的理解和支持，感谢李玲的辛勤工作，感谢江立和李冰，你们的高效让我非常钦佩。我还要感谢孟岩老师，你给我的鼓励我一直记在心里。我要感谢我的挚友郭洪桥，不仅仅因为你在技术上给我的帮助，更加因为你在精神上给我的支持。感谢我的同事和朋友张会昌，你在技术上的广度和深度总令我钦佩。另外，在第一版中帮助我的人，我要再次谢谢你们，因为没有第一版，也就没有第二版。 　　在所有人中我最应该感谢和最想感谢的，是我的妻子黄丹红，感谢你给我的所有建议，还有你帮我画的图。尤其是，当这本书在我预想的时间内没有完成的时候，当我遇到困难迟迟不能解决的时候，你总在一旁给我鼓励，在你那里，我从来都能感觉到一种温暖，我深知，如果没有你的支持，我无法坚持下来将书写完。谢谢你，这本书同样属于你。 　　跟第一版相比，这本书涉及的内容触及操作系统设计的更多方面，而由于笔者的水平实在有限，难免有纰漏甚至错误。如果读者有任何的问题、意见或建议，请登录http://www.osfromscratch.org，让我们共同探讨，共同进步。 　　本书导读 　　这本书适合谁 　　本书是一本操作系统实践的技术书籍。对于操作系统技术感兴趣，想要亲身体验编写操作系统过程的实践主义者，以及Minix、Linux源代码爱好者，都可以在本书中得到实践中所需的知识和思路。 
　　本书以“动手写”为指导思想，只要是跟“动手写”操作系统有关的知识，都作为介绍对象加以讨论，所以，从开发环境的搭建，到保护模式，再到IBMPC中有关芯片的知识，最后到操作系统本身的设计实现，都能在本文中找到相应介绍。所以如果你也想亲身实践的话，本书可以省去你在书店和互联网寻找相应资料的过程，使你的学习过程事半功倍。在读完本书后，你不但可以获得对于操作系统初步的感性认识，并且对 IBMPC的接口、IA架构之保护模式，以及操作系统整体上的框架都将会有一定程度的了解。 　　笔者相信，当你读完本书之后，如果再读那些纯理论性的操作系统书籍，所获得的体验将会完全不同，因为那些对你而言不再是海市蜃楼。 　　对于想阅读 Linux源代码的操作系统爱好者，本书可以提供阅读前所必要的知识储备，而这些知识储备不但在本书中有完整的涉及，而且在很多 Linux书籍中是没有提到的。 　　特别要提到的是，对于想通过阅读 Andrew S. Tanenbaum和 Albert S. Woodhull的《操作系统：设计与实现》来学习操作系统的读者，本书尤其适合作为你的引路书籍，因为它翔实地介绍了初学者入门时所必需的知识积累，而这些知识在《操作系统：设计与实现》一书中是没有涉及的，笔者本人是把这本书作为写操作系统的主要参考书籍之一，所以在本书中对它多有借鉴。 　　你需要什么技术基础 　　在本书中所用到的计算机语言只有两种：汇编和 C语言。所以只要你具备汇编和 C语言的经验，就可以阅读本书。除对操作系统常识性的了解（比如知道中断、进程等概念）之外，本书不假定读者具备其他任何经验。 　　如果你学习过操作系统的理论课程，你会发现本书是对于理论的吻合和补充。它是从实践的角度为你展现一幅操作系统画面。 　　书中涉及了 Intel CPU保护模式、Linux命令等内容，到时候会有尽可能清晰的讲解，如果笔者认为某些内容可以通过其他教材系统学习，会在书中加以说明。 　　另外，本书只涉及 Intel x86平台。 　　统一思想――让我们在这些方面达成共识 　　道篇 　　让我们有效而愉快地学习 　　你大概依然记得在你亲自敲出第一个“Hello world”程序并运行成功时的喜悦，那样的成就感助燃了你对编写程序浓厚的兴趣。随后你不断地学习，每学到新的语法都迫不及待地在计算机上调试运行，在调试的过程中克服困难，学到新知，并获得新的成就感。 　　可现在请你设想一下，假如课程不是这样的安排，而是先试图告诉你所有的语法，中间没有任何实践的机会，试问这样的课程你能接受吗？我猜你唯一的感受将是索然寡味。 　　原因何在？只是因为你不再有因为不断实践而获得的源源不断的成就感。而成就感是学习过程中快乐的源泉，没有了成就感，学习的愉快程度将大打折扣，效果于是也将变得不容乐观。 　　每个人都希望有效而且愉快的学习过程，可不幸的是，我们见到的操作系统课程十之八九令我们失望，作者喋喋不休地讲述着进程管理存储管理I/O控制调度算法，可我们到头来也没有一点的感性认识。我们好像已经理解却又好像一无所知。很明显，没有成就感，一点也没有。笔者痛恨这样的学习过程，也决不会重蹈这样的覆辙，让读者获得成就感将是本书的灵魂。 　　其实这本书完全可以称作一本回忆录，记载了笔者从开始不知道保护模式为何物到最终形成一个小小 　　OS的过程，这样的回忆录性质保证了章节的安排完全遵从操作的时间顺序，于是也就保证了每一步的可操作性，毫无疑问，顺着这样的思路走下来，每一章的成果都需要努力但又尽在眼前，步步为营是我 　　们的战术，成就感是我们的宗旨。 　　我们将从二十行代码开始，让我们最简单的操作系统婴儿慢慢长大，变成一个翩翩少年，而其中的每一步，你都可以在书中的指导下自己完成，不仅仅是看到，而是自己做到！你将在不断的实践中获得不断的成就感，笔者真心希望在阅读本书的过程中，你的学习过程可以变得愉快而有效。 　　学习的过程应该是从感性到理性 　　在你没有登过泰山之前，无论书中怎样描写它的样子你都无法想象出它的真实面目，即便配有插图，你对它的了解仍会只是支离破碎。毫无疑问，一千本对泰山描述的书都比不上你一次登山的经历。文学家的描述可能是华丽而优美的，可这样的描述最终产生的效果可能是你非去亲自登泰山不可。反过来想呢，假如你已经登过泰山，这样的经历产生的效果会是你想读尽天下描述泰山的书而后快吗？可能事实恰恰相反，你可能再也不想去看那些文字描述。 　　是啊，再好的讲述，又哪比得上亲身的体验？人们的认知规律本来如此，有了感性的认识，才能上升为理性的理论。反其道而行之只能是事倍功半。 　　如果操作系统是一座这样的大山，本书愿做你的导游，引领你进入它的门径。传统的操作系统书籍仅仅是给你讲述这座大山的故事，你只是在听讲，并没有身临其境，而随着这本书亲身体验，则好像置身于山门之内，你不但可以看见眼前的每一个细节，更是具有了走完整座大山的信心。 　　值得说明的是，本书旨在引路，不会带领你走完整座大山，但是有兴趣的读者完全可以在本书最终形成的框架的基础上容易地实现其他操作系统书籍中讲到的各种原理和算法，从而对操作系统有个从感性到理性的清醒认识。 　　暂时的错误并不可怕 　　当我们对一件事情的全貌没有很好理解的时候，很可能会对某一部分产生理解上的误差，这就是所谓的断章取义。很多时候断章取义是难免的，但是，在不断学习的过程中，我们会逐渐看到更多，了解更多，对原先事物的认识也会变得深刻甚至不同。 　　对于操作系统这样复杂的东西来说，要想了解所有的细节无疑是非常困难的，所以在实践的过程中，可能在很多地方，会有一些误解发生。这都没有关系，随着了解的深入，这些误解总会得到澄清，到时你会发现，自己对某一方面已经非常熟悉了，这时的成就感，一定会让你感到非常愉悦。 　　本书内容的安排遵从的是代码编写的时间顺序，它更像是一本开发日记，所以在书中一些中间过程不完美的产物被有意保留了下来，并会在以后的章节中对它们进行修改和完善，因为笔者认为，一些精妙的东西背后，一定隐藏着很多中间的产物，一个伟大的发现在很多情况下可能不是天才们刹那间的灵光一闪，背后也一定有着我们没有看到的不伟大甚至是谬误。笔者很想追寻前辈们的脚步，重寻他们当日的足迹。做到这一点无疑很难，但即便无法做到，只要能引起读者的一点思索，也是本书莫大的幸事。 　　挡住了去路的，往往不是大树，而是小藤 　　如果不是亲身去做，你可能永远都不知道，困难是什么。 　　就好像你买了一台功能超全的微波炉回家，研究完了整本说明书，踌躇满志想要烹饪的时候，却突然发现家里的油盐已经用完。而当时已经是晚上十一点，所有的商店都已经关门，你气急败坏，简直想摸起铁勺砸向无辜的微波炉。 　　研究说明书是没有错的，但是在没开始之前，你永远都想不到让你无法烹饪的原因居然是十块钱一瓶的油和一块钱一袋的更加微不足道的盐。你还以为困难是微波炉面板上密密麻麻的控制键盘。 　　其实做其他事情也是一样的，比如写一个操作系统，即便一个很小的可能受理论家们讥笑的操作系统雏形，仍然可能遇到一大堆你没有想过的问题，而这些问题在传统的操作系统书籍中根本没有提到。所以唯一的办法，便是亲自去做，只有实践了，才知道是怎么回事。 　　术篇 　　用到什么再学什么 　　我们不是在考试，我们只是在为了自己的志趣而努力，所以就让我们忠于自己的喜好吧，不必为了考试而看完所有的章节，无论那是多么的乏味。让我们马上投入实践，遇到问题再图解决的办法。笔者非常推崇这样的学习方法： 　　实践 →遇到问题 →解决问题 →再实践 　　因为我们知道我们为什么学习，所以我们才会非常投入；由于我们知道我们的目标是解决什么问题，所以我们才会非常专注；由于我们在实践中学习，所以我们才会非常高效。而最有趣的是，最终你会发现你并没有因为选择这样的学习方法而少学到什么，相反，你会发现你用更少的时间学到更多的东西，并且格外的扎实。 
　　只要用心，就没有学不会的东西 　　笔者还清楚地记得刚刚下载完 Intel Architecture Software Developer Manual那三个可怕的 PDF文件时的心情，那时心里暗暗嘀咕，什么时候才能把这些东西读懂啊！可是突然有一天，当这些东西真的已经被基本读完的时候，我想起当初的畏惧，时间其实并没有过去多少。 　　所有的道理都是相通的，没有什么真正可怕，尤其是，我们所做的并非创造性的工作，所有的问题前人都曾经解决，所以我们更是无所畏惧，更何况我们不仅有书店，而且有互联网，动动手脚就能找到需要的资料，我们只要认真研究就够了。 　　所以当遇到困难时，请静下心来，慢慢研究，因为只要用心，就没有学不会的东西。 　　适当地囫囵吞枣 　　如果囫囵吞枣仅仅是学习的一个过程而非终点，那么它并不一定就是坏事。大家都应该听说过鲁迅先生学习英语的故事，他建议在阅读的过程中遇到不懂的内容可以忽略，等到过一段时间之后，这些问题会自然解决。 　　在本书中，有时候可能先列出一段代码，告诉你它能完成什么，这时你也可以大致读过，因为下面会有对它详细的解释。第一遍读它的时候，你只要了解大概就够了。 　　

本书的原则 　　1.宁可嗦一点，也不肯漏掉细节 　　在书中的有些地方，你可能觉得有些很“简单”的问题都被列了出来，甚至显得有些嗦，但笔者宁可让内容写得嗦点，因为笔者自己在读书的时候有一个体验，就是有时候一个问题怎么也想不通，经过很长时间终于弄明白的时候才发现原来是那么“简单”。可能作者认为它足够简单以至于可以跳过不提，但读者未必那么幸运一下子就弄清楚。 　　不过本书到后面的章节，如果涉及的细节是前面章节提到过的，就有意地略过了。举个非常简单的例子，开始时本书会提醒读者增加一个源文件之后不要忘记修改Makefile，到后来就假定读者已经熟悉了这个步骤，可能就不再提及了。 　　2.努力做到平易近人 
　　笔者更喜欢把本书称作一本笔记或者学习日志，不仅仅是因为它基本是真实的学习过程的再现，而且笔者不想让它有任何居高临下甚至是晦涩神秘的感觉。如果有一个地方你觉得书中没有说清楚以至于你没有弄明白，请你告诉我，我会在以后做出改进。 3.代码注重可读性但不注重效率 　　本书的代码力求简单易懂，在此过程中很少考虑运行的效率。一方面因为书中的代码仅仅供学习之用，暂时并不考虑实际用途；另一方面笔者认为当我们对操作系统足够了解之后再考虑效率的问题也不迟。 　　本书附带光盘说明 　　本书附带光盘中有本书用到的所有源代码。值得一提的是，其中不止包含完整的操作系统代码，还包含各个步骤的中间产物。换句话说，开发中每一步骤的代码，都可在光盘中单独文件夹中找到。举例说明，书的开篇介绍引导扇区，读者在相应文件夹中就只看到引导扇区的代码；第 9章介绍文件系统，在相应文件夹中就不会包含第 10章内存管理的代码。在任何一个步骤对应的文件夹中，都包含一个完整可编译运行的代码树，以方便读者试验之用。这样在学习的任何一个阶段，读者都可彻底了解阶段性成果，且不必担心受到自己还未学习的内容的影响，从而使学习不留死角。 　　在书的正文中引用的代码会标注出出自哪个文件。以“chapter5/b/bar.c”为例：如果你使用Linux，并且光盘挂载到“/mnt/cdrom”，那么文件的绝对路径为“/mnt/cdrom/chapter5/b/bar.c”；如果你使用Windows，并且光盘是 X:盘，那么文件的绝对路径为“X:nchapter5nbnbar.c”。

目 录
　　上 篇 　　第1章 马上动手写一个最小的“操作系统” 2 　　1.1 准备工作 2 　　1.2 十分钟完成的操作系统 3 　　1.3 引导扇区 4 　　1.4 代码解释 4 　　1.5 水面下的冰山 6 　　1.6 回顾 7 　　第2章 搭建你的工作环境 8 　　2.1 虚拟计算机Bochs 8 　　2.1.1 Bochs初体验 8 　　2.1.2 Bochs的安装 9 　　2.1.3 Bochs的使用 10 　　2.1.4 用Bochs调试操作系统 12 　　2.2 QEMU 15 　　2.3 平台之争：Windows还是*nix 16 　　2.4 GNU/Linux下的开发环境 20 　　2.5 Windows下的开发环境 22 　　2.6 总结 23 　　第3章 保护模式（Protect Mode） 25 　　3.1 认识保护模式 25 　　3.1.1 保护模式的运行环境 29 　　3.1.2 GDT（Global Descriptor Table） 31 　　3.1.3 实模式到保护模式，不一般的jmp 33 　　3.1.4 描述符属性 35 　　3.2 保护模式进阶 38 　　3.2.1 海阔凭鱼跃 38 　　3.2.2 LDT（Local Descriptor Table） 44 　　3.2.3 特权级概述 48 　　3.2.4 特权级转移 51 　　3.2.5 关于“保护”二字的一点思考 65 　　3.3 页式存储 65 　　3.3.1 分页机制概述 66 　　3.3.2 编写代码启动分页机制 67 　　3.3.3 PDE和PTE 68 　　3.3.4 cr3 71 　　3.3.5 回头看代码 72 　　3.3.6 克勤克俭用内存 73 　　3.3.7 进一步体会分页机制 81 　　3.4 中断和异常 87 　　3.4.1 中断和异常机制 87 　　3.4.2 外部中断 90 　　3.4.3 编程操作8259A 91 　　3.4.4 建立IDT 94 　　3.4.5 实现一个中断 95 　　3.4.6 时钟中断试验 96 　　3.4.7 几点额外说明 98 　　3.5 保护模式下的I/O 100 　　3.5.1 IOPL 100 　　3.5.2 I/O许可位图（I/O Permission Bitmap） 100 　　3.6 保护模式小结 101 　　第4章 让操作系统走进保护模式 102 　　4.1 突破512字节的限制 102 　　4.1.1 FAT12 103 　　4.1.2 DOS可以识别的引导盘 108 　　4.1.3 一个最简单的Loader 108 　　4.1.4 加载Loader入内存 109 　　4.1.5 向Loader交出控制权 116 　　4.1.6 整理boot.asm 116 　　4.2 保护模式下的“操作系统” 117 　　第5章 内核雏形 119 　　5.1 在Linux下用汇编写Hello World 119 　　5.2 再进一步，汇编和C同步使用 120 　　5.3 ELF（Executable and Linkable Format） 123 　　5.4 从Loader到内核 127 　　5.4.1 用Loader加载ELF 127 　　5.4.2 跳入保护模式 131 　　5.4.3 重新放置内核 137 　　5.4.4 向内核交出控制权 142 　　5.5 扩充内核 143 　　5.5.1 切换堆栈和GDT 144 　　5.5.2 整理我们的文件夹 148 　　5.5.3 Makefile 149 　　5.5.4 添加中断处理 155 　　5.5.5 两点说明 168 　　5.6 小结 169 　　第6章 进程 171 　　6.1 迟到的进程 171 　　6.2 概述 171 　　6.2.1 进程介绍 172 　　6.2.2 未雨绸缪――形成进程的必要考虑 172 　　6.2.3 参考的代码 173 　　6.3 最简单的进程 174 　　6.3.1 简单进程的关键技术预测 175 　　6.3.2 第一步――ring0→ring1 178 　　6.3.3 第二步――丰富中断处理程序 189 　　6.4 多进程 200 　　6.4.1 添加一个进程体 200 　　6.4.2 相关的变量和宏 200 　　6.4.3 进程表初始化代码扩充 202 　　6.4.4 LDT 203 　　6.4.5 修改中断处理程序 203 　　6.4.6 添加一个任务的步骤总结 206 　　6.4.7 号外：Minix的中断处理 207 　　6.4.8 代码回顾与整理 212 　　6.5 系统调用 220 　　6.5.1 实现一个简单的系统调用 222 　　6.5.2 get_ticks的应用 227 　　6.6 进程调度 232 　　6.6.1 避免对称――进程的节奏感 232 　　6.6.2 优先级调度总结 240 　　第7章 输入/输出系统 242 　　7.1 键盘 242 　　7.1.1 从中断开始――键盘初体验 242 　　7.1.2 AT、PS/2键盘 243 　　7.1.3 键盘敲击的过程 244 　　7.1.4 用数组表示扫描码 248 　　7.1.5 键盘输入缓冲区 251 　　7.1.6 用新加的任务处理键盘操作 253 　　7.1.7 解析扫描码 254 　　7.2 显示器 263 　　7.2.1 初识TTY 264 　　7.2.2 基本概念 264 　　7.2.3 寄存器 267 　　7.3 TTY任务 270 　　7.3.1 TTY任务框架的搭建 272 　　7.3.2 多控制台 277 　　7.3.3 完善键盘处理 281 　　7.3.4 TTY任务总结 288 　　7.4 区分任务和用户进程 289 　　7.5 printf 291 　　7.5.1 为进程指定TTY 292 　　7.5.2 printf()的实现 292 　　7.5.3 系统调用write() 294 　　7.5.4 使用printf() 296 　　下 篇 　　第8章 进程间通信 300 　　8.1 微内核还是宏内核 300 　　8.1.1 Linux的系统调用 302 　　8.1.2 Minix的系统调用 303 　　8.1.3 我们的选择 305 　　8.2 IPC 306 　　8.3 实现IPC 306 　　8.3.1 assert()和panic() 309 　　8.3.2 msg_send()和msg_receive() 313 　　8.3.3 增加消息机制之后的进程调度 321 　　8.4 使用IPC来替换系统调用get_ticks 322 　　8.5 总结 324 　　第9章 文件系统 325 　　9.1 硬盘简介 325 　　9.2 硬盘操作的I/O 端口 326 　　9.3 硬盘驱动程序 327 　　9.4 文件系统 337 　　9.5 硬盘分区表 338 　　9.6 设备号 344 　　9.7 用代码遍历所有分区 347 　　9.8 完善硬盘驱动程序 352 　　9.9 在硬盘上制作一个文件系统 355 　　9.9.1 文件系统涉及的数据结构 356 　　9.9.2 编码建立文件系统 358 　　9.10 创建文件 366 　　9.10.1 Linux下的文件操作 366 　　9.10.2 文件描述符（file descriptor） 367 　　9.10.3 open() 369 　　9.11 创建文件所涉及的其他函数 377 　　9.11.1 strip_path() 377 　　9.11.2 search_file() 378 　　9.11.3 get_inode()和sync_inode() 379 　　9.11.4 init_fs() 381 　　9.11.5 read_super_block()和get_super_block() 382 　　9.12 关闭文件 383 　　9.13 查看已创建的文件 384 　　9.14 打开文件 386 　　9.15 读写文件 387 　　9.16 测试文件读写 390 　　9.17 文件系统调试 393 　　9.18 删除文件 395 　　9.19 插曲：奇怪的异常 401 　　9.20 为文件系统添加系统调用的步骤 403 　　9.21 将TTY纳入文件系统 404 　　9.22 改造printf 411 　　9.23 总结 413 　　第10章 内存管理 414 　　10.1 fork 414 　　10.1.1 认识fork 414 　　10.1.2 fork前要做的工作（为fork所做的准备） 417 　　10.1.3 fork()库函数 421 　　10.1.4 MM 421 　　10.1.5 运行 427 　　10.2 exit和wait 427 　　10.3 exec 432 　　10.3.1 认识exec 433 　　10.3.2 为自己的操作系统编写应用程序 434 　　10.3.3 “安装”应用程序 436 　　10.3.4 实现exec 442 　　10.4 简单的shell 447 　　10.5 总结 449 　　第11章 尾声 451 　　11.1 让mkfs()只执行一次 451 　　11.2 从硬盘引导 455 　　11.2.1 编写硬盘引导扇区和硬盘版loader 455 　　11.2.2 “安装”hdboot.bin和hdldr.bin 461 　　11.2.3 grub 461 　　11.2.4 小结 463 　　11.3 将OS安装到真实的计算机 465 　　11.3.1 准备工作 465 　　11.3.2 安装Linux 466 　　11.3.3 编译源代码 466 　　11.3.4 开始安装 467 　　11.4 总结 467 　　参考文献 470




解密《一个操作系统的实现》这本书 




      5 月 18 日见到了《 Orange'S ：一个操作系统的实现》的样书，多少有些激动。想一想前一版本《自己动手写操作系统》是那么畅销，这一本一定不能含糊。整个出版过程我能看到作者于渊为此付出的努力，还在自己排版的过程有深入体会，通过于渊的讲座也让博文视点的员工分享到他在排版过程中的很多心得。   

    应该有几万个朋友读过《自己动手写操作系统》了，本书的第 2 版《 Orange'S ：一个操作系统的实现》出来肯定有非常多的朋友想问，这两本书到底有何区别呢？就此博文视点对本书作者于渊进行了简单的采访。 

     * 提问：《 Orange'S ：一个操作系统的实现》与《自己动手写操作系统》明显区别在哪些方面？ * 

于渊：作为《自己动手写操作系统》（以下简称《自》）的第二版，《 Orange'S ：一个操作系统的实现》（以下简称“新版”）主要有以下变化：   

   1. 书中示例操作系统的名字改为 Orange'S 

   2. 书名改为《 Orange'S ：一个操作系统的实现》 

   3. 增加了有关 IPC 、 FS 、 MM 等内容 

   4. 将默认开发平台改为 GNU/Linux ，同时兼顾 Windows 

   5. 更改了排版工具，并使用技术手段增加书的可读性，比如代码行号的运用 

   6. 建立专门网站以服务读者 

   7. 建立专门讨论区供读者交流 

    读过《自己动手写操作系统》的读者一定知道，其中默认使用 Windows 作为开发平台，同时使用虚拟机来编译及运行自己的 OS ，在新版中这一点发生了变化（如上述第 4 条所述），具体的变化原因在书中第二章有详细的叙述。虽然开发平台是第二位的事情，但书中的默认平台却不免影响到叙述细节，所以，如果读者基于自己的原因坚持在 Windows 上开发（可能的原因或许有对 Linux 不熟悉、需要边开发操作系统边登录某些网上银行等等），则可能对读到的内容进行一点点额外加工。当然，所需的额外加工是少量的，而且在第二章中也有专门的文字介绍如何在两种平台下搭建工作环境。此外，如果读者不介意花钱，还可以同时购买《自己动手写操作系统》和新版，相互参照阅读。 

     * 提问：《 Orange'S ：一个操作系统的实现》与《自己动手写操作系统》相比是否有所增加吗？增加了多少内容量呢？   

     于渊：新版的内容是有增加的，新增文字约占整本书的三分之一，《 Orange'S ：一个操作系统的实现》新增代码则是《自己动手写操作系统》中代码的数倍。这些新增的内容，读者只能从新版中获得。目前并未有将新增内容单独成书的打算，所以读者即便仅想阅读第八章以后的内容，也需要购买整本《 Orange'S ：一个操作系统的实现》。已经购买了《自己动手写操作系统》的读者可能觉得有点浪费，但事实并不如此，因为《自己动手写操作系统》的内容经过了重新排版、修订和编辑（比如代码格式进行了重排，更方便与光盘中的文件对照阅读，以及其中所有的矢量图都用 pgf/TikZ 重新绘制等）笔者倾注的心血使得新版的感官已经大为不同，读者一看便知。 

  * 提问：在《自己动手写操作系统》大卖的时候，您是否想过会有第二版出版呢？ * 

于渊：坦白讲，我在写作《自》的时候，并没有想过今天会有一个第二版。原因在于，我希望这本书是用来填补空白的，而不是重复去做别人已经做得很好的事情。所谓填补空白，具体说就是让像我一样的操作系统爱好者在读完本书之后，能够有信心去读其他比较流行的开源的操作系统代码，有能力从零开始自己动手写操作系统，而这个任务第一版已经完成了。 

  * 提问：那么为什么又写作了第二版呢？ * 

  于渊：原因有几个方面。第一，虽然第一版未曾涉及的进程间通信、文件系统等内容在许多书中都有讲解，但阅读的时候还是感觉有语焉不详的通病，作者本人可能很清楚原委，但写得太简略，以至于读者看来未必清晰。第二，我自己想把这个圈画圆。第一版的书虽然完成了它的使命，但毕竟到书的结尾，读者看到的不是一个真正的操作系统，它没有文件系统，没有内存管理，什么也干不了。在第二版中，你将会看到，你已经可以通过交叉编译的方式为我们的实验性 OS 编写应用程序了，也就是说，它已经具备操作系统的基本功能，虽然仍然极其简陋，但第一个圈，毕竟是已经圆起来了。第三，实践类的操作系统书籍还是太少了，以至于你要想看看别人是怎么做的，除了读以《操作系统：设计与实现》为代表的极少数书籍之外，就是一头扎进源代码中，而结果有时相当令人气馁。我自己也气馁过，所以我在第二版中，仍然试图把话说细一点，把自己的经验拿出来分享。而且我选择我能想到的最精简的设计，以便让读者不至于陷入太多细节而无法看到全貌。我想这是本书可能具有的价值所在──简化的易懂的设计，还有尽量详细的文字。 

  * 提问：这本书为何不考虑用 WORD 排版？ * 

   于渊：新版的排版是我用 LaTeX 自己完成的。在排版中我花了一些工夫，因为我希望读者购买的首先是一本易于阅读且赏心悦目的书，其次才是编写操作系统的方法。另外，书中列出的代码均由我自己编写的程序自动嵌入 LaTeX 源文件，从而严格保证书和光盘的一致性，读者可以根据文件名和行号方便地找到光盘中代码的准确位置。 

  * 提问：第二版还有哪些区别呢？ Orange'S 这个名字很特别，有什么寓意吗？ * 

    于渊：新版中还有一些小的变化。首先是操作系统的名字改变了，原因在于虽然我们的试验性 OS 从前辈们那里借鉴了很多东西，但其各个部分的设计（比如文件系统和内存管理）往往有其独特之处，所以我将原先的 Tinix （本意为 TryMinix ）改成了新名字 Orange'S （这个名字来自于我的妻子），以表示它们的不同。另外，书中的代码风格，有些地方也做了调整。 

    新版中，原先的叙述风格都尽量地得以贯彻，而在表现形式上，新版用了更多心思，我相信读者能在其中发现这些特点：关注动手细节，探寻代码背后的故事，结果与过程兼顾，内容与形式并重。加上专门为本书建立的网站和讨论区，我相信读者能更容易地阅读，更轻松地学习。 

更多详情请登录 http://osfromscratch.org/ 。 



